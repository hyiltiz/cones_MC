clear variables
addpath(genpath(pwd))


%% WHAT THIS CODE DOES
%
% 1 Generate cone positions on an M-by-M pixel array by running 
%   MCMC with log-likelihood  prior_LL  over cone positions.
%
% 2 Generate ganglion cells by choosing the number of spikes
%   N_spikes(i)   for each GC i = 1..N_cells  = ceil( M^2/10 ).
%   Ganglion cell RFs are generated by drawing a gaussian
%   connectivity matrix between GCs and cones. STAs are noisy RFs,
%   generated by assuming that ganglion cells are LNP/exponential.
%
% 3 Do greedy search for cone positions.
%
% 4 Run MCMC on the same problem with the same log-likelihood.



%% MAIN PARAMETERS OF THE PROBLEM
%
% M             size of the Region of Interest: M-by-M
  M           = 15 ;

% N_cells       number of ganglion cells
  N_cells     = ceil( M^2/10 ) ;
  
% T             number of time samples in 'experiment'
  T           = 100000 ;

% N_spikes      THIS IS THE MOST IMPORTANT PARAMETER
%               number of GC spikes  --  array of size N_cells
%               - for large numbers of spikes, both the greedy and MCMC
%               do a good job finding the actual cone positions
%               - for small numbers of spikes, the problem gets much harder
%               because many local minima plague the log-likelihood
%
%       comment/uncomment to toggle between EASY and HARD cases
%
%       EASY case
      N_spikes = floor( T * exp( log(0.01) : (log(0.1)-log(0.01))/(N_cells-1) : log(0.1) ) ) ;  
%
%       HARD case
%         N_spikes = floor( T * exp( log(0.01) : (log(0.1)-log(0.01))/(N_cells-1) : log(0.1) ) / 10 ) ;



%% PARAMETERS FOR MCMC
TOTAL_trials    = 50 * M^2 ;
burn_in         = 50 * M^2 ;
%               to speed up, reduce both of these, although results will be
%               slightly degraded.

% plot instances every ? iterations (0 for never)
plot_every      = 5 ;

% these params shouldn't need tweaking unless the problem setup changes
%        
% prior_LL      prior used both for greedy and MCMC
%
% betas         instance X_i has inverse temperature betas(i)
  betas         = [1 0.25 0.2 0.2 0.2 0.15] ;
%               X_1 is the main instance.
%               X_(2..N-1) are a pool of warm instances.
%               X_N is a hot instance that provides randomness to the pool.
%               to speed up, reduce number of instances by using for
%               example betas = [1 0.2 0.2 0.15], although results might be
%               slightly degraded.
%
% moves         sequence of moves at each iteration, currently:
%               - 3 regular MC moves for each instance
%               - one swap between X_1 and each X_(2..N-1)
%               - one swap among each pair of   X_(2..N-1)
%               - one swap between X_N and each X_(2..N-1)



%% WHAT MCMC IS DOING: the short version 
% The MCMC used here is a combination of parallel tempering, aka replica 
% exchange MC, and cluster MC, with clusters adapted to our problem.
%
% 6 MC instances are run in parallel: one with the actual log-likelihood LL
% the other 5 instances i with log-likelihood LL * betas(i) < LL.
% Once in while, connected components of the symmetric difference between 
% pairs of instance configurations are swapped between instances.



%% PROBLEM SETUP: cone positions

% sigmoidal penalty for cones that are too close
sigmoid = @ (x) 2*(  (x<0.5).*(x.^2) + (x>=0.5).*(-(x-1).^2+0.5)  );

% penalty h for cones that are too close 
% if x is between 0 and 1 then use sigmoid, else x is 1 or realmin
% (i.e. very close to zero, while still having its log defined)
c1 = 1.5 ;
c2 = 2.5 ;
h = @(x) ((x>0  ).*(x<=c1)  .* (-1)      + ...
          (x>=c2)           .* (realmin) + ...
         ((x>c1 ).*(x< c2)) .* (-1+ 1.3*sigmoid((x-c1)./(c2-c1)))) ;

% resulting cone position log prior
factor = 10 ;
position_key = [repmat(1:M,1,M) ; reshape(repmat(1:M,M,1),[],1)'] ;
lprior_cone_position = @(state) factor * sum( sum( h( pair_dist(position_key(:,state))))) ;

% draw position of cones : MCMC burn-in with lprior_cone_position
X.state     = zeros(1,M^2) ;
n_trials    = 10 ;
avg_cones   = 0 ;
flat_prob   = cumsum(1:M^2) * 2 / (M^2*(M^2+1)) ;
for i=1:M^2
    [ avg_cones , X ] = flip_MCMC( avg_cones , X , @(y)sum(y,2) , ...
        @(X)independent_sampler(X,flat_prob,n_trials) , ...
        @(X,flips)simple_flipper(X,flips,lprior_cone_position) ) ;
end
cones = X ;
cone_positions = X.state ;
N_cones = sum(cone_positions(:)) ;



%% PROBLEM SETUP: ganglion cell STAs

% stereotyped cone receptive field
cone_RF = exp(-0.5 * (-2:2).^2)' * exp(-0.5 * (-2:2).^2) ;
cone_RF = cone_RF / sum(cone_RF(:)) ;

% W = matrix representing all M^2 possible cone receptive fields
W = reshape( eye(M^2,M^2) , [M M M M] ) ;
for i=1:M
    for j=1:M
        W(:,:,i,j) = imfilter( W(:,:,i,j) , cone_RF ) ;
    end
end
W = reshape( W , [M^2 M^2] ) ;

% connection weights between cones and ganglion cells
A = 0.2 * (randn( N_cones , N_cells ) + 1) ;

% resulting Receptive Fields
RF = W(:,cone_positions) * A ;

% actual STA is a noisy RF: assume  exp(a * (STA'*input)) poisson spiking,
% where  a = steepness / std( STA'*input )
steepness = 2 ;  % larger means harder threshold
STA = RF ;
STA_norm = zeros(1,N_cells) ;
for i=1:N_cells
    variance = sum(RF(:,i).^2) ;
    standard_deviation = sqrt( variance - RF(:,i).^2 ) ;
    p        = 1 - 1./( exp( RF(:,i)*steepness./standard_deviation ) + 1 ) ;

    % black stimulus = -1   ;   white stimulus = 1    ;   sigma = 1
    STA(:,i) = 2 * binornd( N_spikes(i) , p ) / N_spikes(i) - 1 ;
    STA_norm(i) = norm(STA(:,i)) ;
end

% PLOT some RFs and STAs
scrsz = get(0,'ScreenSize');
figure('Position',[1 scrsz(4)*0.7 1000 800])
subplot(2,2,1)
imagesc(reshape(RF(:,1),M,M))
title('RF Cell 1','FontSize',20)
subplot(2,2,2)
imagesc(reshape(STA(:,1),M,M))
title(sprintf('STA Cell 1 , %d spikes',N_spikes(1)),'FontSize',20)
subplot(2,2,3)
imagesc(reshape(RF(:,end),M,M))
title(sprintf('RF Cell %d',length(N_spikes)),'FontSize',20)
subplot(2,2,4)
imagesc(reshape(STA(:,end),M,M))
title(sprintf('STA Cell %d , %d spikes',length(N_spikes),N_spikes(end)),'FontSize',20)

% PLOT histogram of numbers of spikes
figure('Position',[scrsz(3)-400 scrsz(4)/2 400 400])
hist(N_spikes,N_cells/2)
ylabel('Number of GC cells','FontSize',20)
xlabel('Number of spikes','FontSize',20)
title({'Histogram of GC spike counts',sprintf('%d Cells',N_cells)},'FontSize',22)
drawnow

%% SETUP for Log-LIKELIHOOD calculations
cell_consts = N_spikes ./ exp(STA_norm/2) ;
STA_W       = STA' * W .* repmat( N_spikes ./ cell_consts ,M^2,1)' ;
WW          = W' * W ;

coneConv    = conv2(cone_RF,cone_RF) ;

prior_LL    = @(X)lprior_cone_position(X.state) ;

clear X



%% GREEDY SOLUTION
GREED.state  = zeros( 1 , M^2 ) ;
best_LL      = -Inf ;

% flip_LL      = @(X,flips)flip_conv_LL( X , flips , prior_LL , cell_consts , STA_W , coneConv , [M M] ) ;
flip_LL      = @(X,flips)flip_STA_LL( X , flips , prior_LL , cell_consts , STA_W , WW ) ;

fprintf('\nGREEDY cone finding:\n')
tic
while 1
    GREED = greedy( GREED , flip_LL ) ;
    fprintf('\nCONES:%2d \t \t increase in LL:%f',sum(GREED.state),GREED.ll-best_LL)
    if GREED.ll<=best_LL
        break
    else
        best_LL = GREED.ll ;
    end
end
fprintf('\nGREEDY SOLUTION found in %.1f sec\n',toc)

% PLOT GREEDY SOLUTION
scrsz = get(0,'ScreenSize');
figure('Position',[scrsz(4)/2-250 scrsz(4)*0.5 500 530])
hold on
colormap('pink')
GREEDcolor = double( GREED.state ) ;
GREEDcolor(GREED.history) = ceil( numel(GREED.history)/3 ) + (length(GREED.history):-1:1) ;
imagesc(reshape(GREEDcolor,M,M))
xy = position_key(:,cone_positions) ;
plot(xy(2,:),xy(1,:),'g.')
set(gca,'Visible','off')
title({'GREEDY solution' ; 'green dots: true cone locations' ; 'light pixels found first'},'FontSize',24)
set(get(gca,'Title'),'Visible','on')
drawnow


%% MCMC RUN
N_instances     = length(betas) ;
n_trials        = 10 ;
fprintf('\n\nSTARTING %d MCMC instances with different inverse temperatures beta:\n',N_instances)
fprintf('%.2f   ',betas)

% initializing variables
flat_probs      = ones(1,M^2)/M^2 ;
flip_LL         = cell( N_instances , 1 ) ;
accumulated     = cell( N_instances , 1 ) ;
accumulator     = cell( N_instances , 1 ) ;
flipper         = cell( N_instances , 1 ) ;
jitter          = cell( N_instances , 1 ) ;
blurbs          = cell( N_instances , 1 ) ;
X               = cell( N_instances , 1 ) ;
% prior_LL        = @(X)0 ; %lprior_cone_position(X.state) ;

for i=1:N_instances
    X{i}.state      = zeros( 1 , M^2     ) ;
    accumulated{i}  = zeros( 1 , M^2 + 2 ) ;
    accumulator{i}  = @(y)[ones(size(y,1),1) sum(y,2) y] ;
    flipper{i}      = @(X)independent_sampler(X,ones(1,M^2)/M^2,n_trials) ;
    jitter{i}       = @(X)jitter_sampler( X , flat_probs , n_trials , M ) ;
    flip_LL{i}      = @(X,flips)flip_conv_LL( X , flips , prior_LL , cell_consts , STA_W , coneConv , [M M] , betas(i)) ;
end

if plot_every
    h = figure('Position',[1 scrsz(4)*0.7 1500 250]) ;
end

% MC move sequence
temp0   = repmat(2:N_instances-1,N_instances-2,1) ;
temp1   = temp0' ;
choose  = logical( tril(ones(N_instances-2),-1) ) ;
pairs   = [temp1(choose) temp0(choose)]' ;

moves   = [ num2cell(  repmat( 1:N_instances , 1 , N_instances-2 ) )                ...
            {{'plot instances every' plot_every}}                                   ...
            num2cell( pairs , 1)                                                    ...
            num2cell( [ N_instances-1:-1:2 ; N_instances*ones(1,N_instances-2)] ,1) ...
            num2cell( [         ones(1,N_instances-2) ; N_instances-1:-1:2] , 1 )   ] ;

N_moves      = length(moves) ;
burn_in      = ceil( burn_in / (n_trials * N_moves) ) ;
N_iterations = burn_in + ceil( TOTAL_trials / (n_trials * N_moves) ) ;
n_cones      = zeros( N_iterations , 1 ) ;

% MAIN MCMC LOOP
fprintf('\n\n      MCMC progress\n|0%%              100%%|\n ')
tic
for jj=1:N_iterations
    if ~mod(jj,floor(N_iterations/20)) , fprintf('*') , end
    
    for j=1:N_moves
        this_move = moves{j} ;

        % either plot configurations
        if iscell(this_move) && ~isempty(this_move) && ~mod(jj,this_move{2}) && jj>burn_in*0.8
            if ~this_move{2} , clf ; end
            figure(h)
            for i=1:N_instances
                subplot(1,N_instances,i)
                hold on
                colormap('pink')
                imagesc(reshape(X{i}.state,M,M))
                xy = position_key(:,cone_positions) ;
                plot(xy(2,:),xy(1,:),'g.')
                set(gca,'Visible','off')
                titl = sprintf('X_%d   \\beta %.2f',i,betas(i)) ;
                if i == ceil(N_instances/2)
                    title({sprintf('Iteration %d',jj) ; titl },'FontSize',22)
                else
                    title( titl , 'FontSize',22)
                end
                set(get(gca,'Title'),'Visible','on')
            end
            drawnow
            
        % or do MC move
        elseif isnumeric(this_move)
            i = this_move(1) ;
            
            % swap move if this_move has 2 indices
            if length(this_move) == 2 && jj>burn_in*0.8
                swapX = swapper( X{i} , X{this_move(2)} ) ;
                swap_flipper = @(swapX,flips) swap_LL(swapX,flips, flip_LL{i} , flip_LL{this_move(2)}) ;

                if ~isempty(swapX.flips)
                    for ii=1:2
                    [ accumulated{i} , swapX ] = ...
                        flip_MCMC( accumulated{i} , swapX , accumulator{i} , @(X)X.flips , swap_flipper ) ;
                    end
                    X{i} = swapX.X ; X{this_move(2)} = swapX.with ;
                end
                
            % regular MCMC move if this_move has one index
            elseif length(this_move) == 1
                i = this_move ;
                [ accumulated{i} , X{i} ] = ...
                    flip_MCMC( accumulated{i} , X{i} , accumulator{i} , jitter{i} , flip_LL{i} ) ;
            end
            n_cones(jj) = sum(X{1}.state) ;
        end
    end

end
fprintf('    done in %.1f sec\n\n',toc) ;


%% PLOT MCMC RESULTS

% number of cones
figure ; hold on
plot( n_trials*(1:length(n_cones)) , n_cones )
plot( [1 1]*burn_in*n_trials , [1 max(n_cones)] )
xlabel('MCMC iteration','FontSize',18)
ylabel('# of cones','FontSize',18)
title('Burn in','FontSize',22)

% final results
figure('Position',[1 scrsz(4) 650 500])

xy = position_key(:,cone_positions) ;
hold on
colormap('pink')
imagesc(reshape( accumulated{1}(3:end) / accumulated{1}(1)    ,M,M))
plot(xy(2,:),xy(1,:),'g.')
colorbar
set(gca,'Visible','off')
title('MCMC: mean occupancy','FontSize',22)
set(get(gca,'Title'),'Visible','on')

% top ten configurations
figure('Position',[1 scrsz(4)*0.7 1500 600])

cone_positions  = flip_conv_LL( cones , [] , prior_LL , cell_consts , STA_W , coneConv , [M M] ) ;
actual_LL       = cone_positions.ll ;

for i=1:10
    subplot(2,5,i)
    hold on
    colormap('pink')
    imagesc(reshape( X{1}.best(11-i,2:end),M,M))
    plot(xy(2,:),xy(1,:),'g.')
    set(gca,'Visible','off')
    titl = sprintf( 'LL: %.2f' , X{1}.best(11-i) - actual_LL ) ;
    if i == 3
        title({'Top 10 configurations' ; titl},'FontSize',22)
    elseif i == 8
        title({'True cone position LL: 0' ; titl},'FontSize',22)
    else
        title(titl,'FontSize',22)
    end
    set(get(gca,'Title'),'Visible','on')
    
end