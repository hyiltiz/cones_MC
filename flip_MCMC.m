function X = flip_MCMC( X , trials , PROB, temps )
% Propagate configuration 'X' and accumulated observable 'result' through
% one iteration of MCMC. Trials are generated by 'trial_sampler', which
% also calculates log-likelihoods, and the resulting observables
% accumulated by 'accumulate'. If 'trial_sampler' returns a single trial,
% then the metropolis-hastings rule is used. For more than one trial, the
% symmetric MC rule is used.

if ~isempty(trials)
    
    % prepend current X to samples
    trials   = [{X} ; trials(:)] ;
    n_trials = length(trials) ;
    clear X
    
    % calculate the log-likelihoods of proposed trials
    ll      = zeros(1,n_trials) ;
    for i=1:n_trials        
        if numel(temps)<2
            ll(i) = get_LL( trials{i}, PROB, temps{1}) ;
        else
            ll(i) = get_LL( trials{i}.X, PROB, temps{1}) + get_LL( trials{i}.with, PROB, temps{1}) ;
        end
    end
    
    % get likelihood vector of trials
    L = exp( ll - max(ll) ) ;
    L = L/sum(L) ;
    
    % choose next state
    
    % symmetric rule
    trans_prior = zeros(n_trials,1) ;
    for i=2:n_trials
        trans_prior(i) = trials{i}.forward_prob ;
    end
    trans_prior(1) = sum(trans_prior)/(n_trials) ;
    p = L./trans_prior' ;
    p = cumsum(p) ;
    p = p/p(end) ;
    try
        i = randiscrete( p ) ;
    catch
        L
        L./trans_prior'
    end
    if numel(temps)<2
        X = update_X( trials , i ) ;
    else
        X = update_swap( trials , i ) ;
    end
else
    if numel(temps)<2
        X = update_X( {X} , 1 ) ;
    else
        X = update_swap( {X} , 1 ) ;
    end
end



% else                % metropolis_hastings
%     i = rand() < ( (L(2) * flip_me{1}.backward_prob) / ...
%                    (L(1) * flip_me{1}.forward_prob ) ) ;
%     X = trials{i+1} ;
%     % accumulate observable
%     result = result + accumulate( y(i+1,:) ) ;
% end

% fprintf('\nn_trials%3d (chose%4d)  at %5f sec/trial',n_trials,i,toc/n_trials)

end