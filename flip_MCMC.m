function [ result , X ] = flip_MCMC( result , X , accumulate , trial_sampler , flip_LL )
% Propagate configuration 'X' and accumulated observable 'result' through
% one iteration of MCMC. Trials are generated by 'trial_sampler', their
% log-likelihoods calculated by 'flip_LL', and the resulting observables
% accumulated by 'accumulate'. If 'trial_sampler' returns a single trial,
% then the metropolis-hastings rule is used. For more than one trial, the
% symmetric MC rule is used.

% choose which bits to flip
flip_me  = trial_sampler( X ) ;
n_trials = length(flip_me) ;

% initialize output aux
Ys = cell(n_trials,1) ;
Ys{1} = flip_LL( X , [] ) ;

% initialize trial configurations y and log-likelihoods
y       = repmat(X.state , n_trials+1, 1) ;
ll      = zeros(1,n_trials+1) ;
ll(1)   = Ys{1}.ll ;
clear X

% calculate the log-likelihoods of proposed trials, and populate y
for i=2:n_trials+1
    y(i,flip_me{i-1}.flips) = ~y(i,flip_me{i-1}.flips) ;
    Ys{i} = flip_LL( Ys{1} , flip_me{i-1}.flips ) ;
    ll(i) = Ys{i}.ll ;
end

% get likelihood vector of trials
L = exp( ll - max(ll) ) ;
L = L/sum(L) ;

% choose next state
if n_trials>1       % symmetric rule    
    trans_prior = zeros(n_trials+1,1) ;
    for i=1:n_trials
       trans_prior(i+1) = flip_me{i}.forward_prob ;
    end
    trans_prior(1) = sum(trans_prior)/(n_trials+1) ;
    p = L./trans_prior' ; p = p/sum(p) ;
        
    i = randiscrete( p ) ;
    X = Ys{i} ;
    
    % accumulate observable
    result = result + sum( L * accumulate( y ) , 1 ) ;

else                % metropolis_hastings
    i = rand() < ( (L(2) * flip_me{1}.backward_prob) / ...
                   (L(1) * flip_me{1}.forward_prob ) ) ;
    X = Ys{i+1} ;

    % accumulate observable
    result = result + accumulate( y(i+1,:) ) ;
end

end